# bodhi-slam
bodhi-slam is an ORM for the Bodhi API which provides a simple DSL for interacting with resources in the cloud.

## Compatiblity
bodhi-slam has been tested on: MRI Ruby 2.0, 2.1, 2.2, and JRuby 9.0.0

## Installation
    gem install bodhi-slam

or add the following to your Gemfile:

    gem 'bodhi-slam'

## Basic Usage
### Setup
    require 'bodhi-slam'
    context = Bodhi::Context.new(server: "SERVER_URL", namespace: "NAMESPACE_NAME", username: "USERNAME", password: "PASSWORD")
    klasses = BodhiSlam.analyze(context)

The `BodhiSlam.analyze` method returns an array of classes built from all `Bodhi::Type` records in the namespace.
These classes will also be defined globally as constants using the `Bodhi::Type` name.

For example:  The `Bodhi::Type` named "Store" will be converted into a Ruby class named "Store" and set to the constant `Store`.  This helps enable the interface for interacting with Bodhi::Resources described below.

### Bodhi::Context


**All requests to the Bodhi API must be done using a `Bodhi::Context` object.**

    options = { server: "SERVER_URL", namespace: "NAMESPACE_NAME", username: "NAME", password: "PASSWORD" }
    context = Bodhi::Context.new(options)

Additionally, a `Bodhi::Context` can be initialized to use `COOKIE_AUTH` with the following options:

    options = { server: "SERVER_URL", namespace: "NAMESPACE_NAME", username: "NAME", cookie: "COOKIE" }
    context = Bodhi::Context.new(options)

**TIP: It's best to use COOKIE_AUTH whenever possible for performance reasons**

If you plan to re-use the same context, then you can set it globally by using:

    Bodhi::Context.global_context = context
    Bodhi::Context.global_context #=> returns the current global context

**Warning: Using the global context is not thread safe!  Beware of race conditions!**
#### Context Validations

    context = Bodhi::Context.new
    context.valid?      #=> false
    context.errors.any? #=> true
    context.errors.to_a #=> ["server is required", "namespace is required"]

### Resources
All resources inherit the following interface.

    Resource.all
    Resource.count
    Resource.find(sys_id)
    Resource.where(query)
    Resource.aggregate(pipeline)
    Resource.save_batch(records_array)
    Resource.delete_all
    
    record = Resource.new(bodhi_context: context)
    record.attributes #=> returns a Hash of the resource's properties and their current values
    record.save       #=> saves the resource to the cloud
    record.delete     #=> deletes the resource from the cloud
    record.update(attributes) #=> updates the resource with the given attributes
    record.patch(op: "replace", path: "/display_name", value: "test")
    
    record.persisted?  #=> false
    record.new_record? #=> true

#### Factories
All `Bodhi::Resource` have pre-defined factories based on the parent `Bodhi::Type`.  The factory will be built using the defined properties and validations from the `Bodhi::Type`.  New records can be randomly generated by using the resource's `factory.<command>` methods.  For example:

    Resource.factory.build(options)            #=> returns a randomly generated record
    Resource.factory.create(options)           #=> returns a randomly generated record and saves to the cloud
    Resource.factory.build_list(qty, options)  #=> returns an array of randomly generated records
    Resource.factory.create_list(qty, options) #=> returns an array of randomly generated records and saves each to the cloud

If you want to set a non-random property, simply add that property and value to the options hash.
All other properties will still be randomly generated.

    Resource.factory.build(name: "test", some_number: 12345)

**NOTE:  When generating a list of random records, any property set in the options hash will be applied to ALL records in the list**

#### Validations
    record = Resource.new
    record.valid?      #=> false
    record.errors.any? #=> true
    record.errors.to_a #=> ["name is required", "store_number can not be blank"]

#### Batch Uploads
This feature utilizes MongoDB batch uploads for increased performance when inserting lots of records.  The `Resource.save_batch` method returns a `Bodhi::ResourceBatch` object, which contains the failed and created records.

    records = Resource.factory.build_list(5000, bodhi_context: context)
    batch = Resource.save_batch(records)
    batch.created #=> returns an array of all recrods that were saved
    batch.failed  #=> returns an array of all recrods that failed to save

#### Query Interface
Basic query structure:

    Resource.where("{ name: 'test' }").from(context).all   #=> returns array of all records that matched
    Resource.where("{ name: 'test' }").from(context).first #=> returns the first record that matches
    Resource.where("{ name: 'test' }").from(context).last  #=> returns the last record that matches

Additional methods:

    Resource.where(query).select("field1, field2, field3")
    Resource.where(query).and(other_query)
    Resource.where(query).sort(field_name, order)
    Resource.where(query).page(page_number)
    Resource.where(query).limit(size)

#### Aggregation Interface
The Bodhi API uses the MongoDB Aggregation Framework.  See the [MongoDB Aggregation](https://docs.mongodb.org/manual/aggregation/) page for more info on how to format your aggregation pipelines.

    pipeline = { "$match" => { name: "My Awesome Thing" } }.to_json
    Resource.aggregate(pipeline) #=> returns a Hash of the JSON response from the cloud
